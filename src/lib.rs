// Editorjs2Html
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/MKJSM/MKJS/refs/heads/main/mkjs_circle.png"
)]

use anyhow::{anyhow, Result};

mod models;
mod renderers;

use models::*;
use renderers::*;
use serde_json::Value;

/// Converts an Editor.js JSON string into an HTML representation.
///
/// This function takes a JSON-formatted string generated by [Editor.js](https://editorjs.io/)
/// and converts it into HTML. It is useful for rendering rich text content stored in Editor.js format
/// in web applications.
///
/// # Arguments
///
/// * `str` - A string slice containing the Editor.js JSON.
///
/// # Returns
///
/// * `Ok(String)` - The generated HTML string if the conversion is successful.
/// * `Err(anyhow::Error)` - An error if the JSON is invalid or cannot be parsed.
///
/// # Example
///
/// ```
/// let editor_json = serde_json::json!({
///     "time": 1612345678901i64,
///     "blocks": [
///         { "type": "paragraph", "data": { "text": "Hello, world!" } },
///         { "type": "header", "data": { "text": "Welcome", "level": 2 } }
///     ],
///     "version": "2.22.2"
/// });
/// let html_content = editorjs2html::string_to_html(&editor_json.to_string()).unwrap();
/// assert_eq!(html_content, "<div class=\"js-para\"><p>Hello, world!</p></div><div class=\"js-head\"><h2>Welcome</h2></div>");
/// ```
///
/// # Errors
///
/// This function may return an error if:
/// * The input is not valid JSON.
/// * The JSON structure does not conform to Editor.js format.
/// * The function encounters an unsupported block type.
///
/// # Notes
///
/// * The function assumes that the input follows the standard [Editor.js JSON format](https://editorjs.io/base-concepts).
/// * Not all Editor.js block types may be supported in the implementation.
pub fn string_to_html(str: &str) -> Result<String> {
    let document: Document = serde_json::from_str(str)
        .map_err(|e| anyhow!("Error while parsing to blocks: {}", e.to_string()))?;
    Ok(to_html(document))
}

/// Converts an Editor.js JSON value into an HTML representation.
///
/// This function takes a JSON value generated by [Editor.js](https://editorjs.io/)
/// and converts it into HTML. It is useful for rendering rich text content stored in Editor.js format
/// in web applications.
///
/// # Arguments
///
/// * `serde_json::Value` - A value containing the Editor.js JSON.
///
/// # Returns
///
/// * `Ok(String)` - The generated HTML string if the conversion is successful.
/// * `Err(anyhow::Error)` - An error if the JSON is invalid or cannot be parsed.
///
/// # Example
///
/// ```
/// let editor_json = serde_json::json!({
///     "time": 1612345678901i64,
///     "blocks": [
///         { "type": "paragraph", "data": { "text": "Hello, world!" } },
///         { "type": "header", "data": { "text": "Welcome", "level": 2 } }
///     ],
///     "version": "2.22.2"
/// });
/// let html_content = editorjs2html::value_to_html(&editor_json).unwrap();
/// assert_eq!(html_content, "<div class=\"js-para\"><p>Hello, world!</p></div><div class=\"js-head\"><h2>Welcome</h2></div>");
/// ```
///
/// # Errors
///
/// This function may return an error if:
/// * The input is not valid JSON.
/// * The JSON structure does not conform to Editor.js format.
/// * The function encounters an unsupported block type.
///
/// # Notes
///
/// * The function assumes that the input follows the standard [Editor.js JSON format](https://editorjs.io/base-concepts).
/// * Not all Editor.js block types may be supported in the implementation.
pub fn value_to_html(value: &Value) -> Result<String> {
    let document: Document = serde_json::from_value(value.clone())
        .map_err(|e| anyhow!("Error while parsing to blocks: {}", e.to_string()))?;
    Ok(to_html(document))
}

fn to_html(document: Document) -> String {
    let mut html_string = String::new();
    let mut has_toggle = false;

    let mut i = 0;
    let block_len = document.blocks.len();
    while i < block_len {
        let block = document.blocks[i].clone();
        if block.r#type == "toggle" {
            if let Some(item) = block.data.items {
                if let Some(count) = item.as_u64() {
                    has_toggle = true;
                    let label = block.data.text.unwrap_or_else(|| "Toggle".to_string());
                    let fk = block.data.fk.unwrap_or_else(|| format!("toggle-{}", i));
                    let status = block.data.status.unwrap_or_else(|| "open".into());
                    let display = if status == "closed" { "none" } else { "block" };

                    let mut nested_html = String::new();
                    for j in (i + 1)..(i + 1 + count as usize).min(block_len) {
                        let nested_block = document.blocks[j].clone();
                        nested_html.push_str(&render_block(nested_block));
                    }

                    html_string.push_str(&format!(
                    "<div class=\"js-toggle\" data-fk=\"{fk}\" data-status=\"{status}\" data-items=\"{items}\">
                        <div class=\"js-toggle-label\" onclick=\"toggleContent('{fk}')\">{label}</div>
                        <div id=\"{fk}\" class=\"js-toggle-content\" style=\"display: {display};\">
                            {nested_html}
                        </div>
                    </div>",
                    fk = fk,
                    status = status,
                    items = count,
                    label = label,
                    display = display,
                    nested_html = nested_html
                ));

                    i += 1 + count as usize;
                } else {
                    i += 1;
                }
            } else {
                i += 1;
            }
        } else {
            html_string.push_str(&render_block(block));
            i += 1;
        }
    }

    if has_toggle {
        html_string.push_str(
            r#"<style>
                    .toggle-label {
                        cursor: pointer;
                        font-weight: bold;
                        padding: 0.5em;
                        background-color: #f0f0f0;
                        border: 1px solid #ccc;
                        border-radius: 5px;
                    }
                    .toggle-label:hover {
                        background-color: #e0e0e0;
                    }
                    .toggle-content {
                        padding: 0.5em 1em;
                        border-left: 2px solid #ccc;
                        margin-top: 0.5em;
                    }
                </style>
                <script>
                    function toggleContent(fk) {
                        const content = document.getElementById(fk);
                        if (!content) return;
                        const isVisible = content.style.display === 'block';
                        content.style.display = isVisible ? 'none' : 'block';
                    }
                </script>"#,
        );
    }
    html_string
}
