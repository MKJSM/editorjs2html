// Editorjs2Html
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/MKJSM/MKJS/refs/heads/main/mkjs_circle.png"
)]

use anyhow::{anyhow, Result};

mod models;
mod renderers;

use models::*;
use renderers::*;
use serde_json::Value;

/// Converts an Editor.js JSON string into an HTML representation.
///
/// This function takes a JSON-formatted string generated by [Editor.js](https://editorjs.io/)
/// and converts it into HTML. It is useful for rendering rich text content stored in Editor.js format
/// in web applications.
///
/// # Arguments
///
/// * `str` - A string slice containing the Editor.js JSON.
///
/// # Returns
///
/// * `Ok(String)` - The generated HTML string if the conversion is successful.
/// * `Err(anyhow::Error)` - An error if the JSON is invalid or cannot be parsed.
///
/// # Example
///
/// ```
/// let editor_json = serde_json::json!({
///     "time": 1612345678901i64,
///     "blocks": [
///         { "type": "paragraph", "data": { "text": "Hello, world!" } },
///         { "type": "header", "data": { "text": "Welcome", "level": 2 } }
///     ],
///     "version": "2.22.2"
/// });
/// let html_content = editorjs2html::string_to_html(&editor_json.to_string()).unwrap();
/// assert_eq!(html_content, "<div class=\"js-para\"><p>Hello, world!</p></div><div class=\"js-head\"><h2>Welcome</h2></div>");
/// ```
///
/// # Errors
///
/// This function may return an error if:
/// * The input is not valid JSON.
/// * The JSON structure does not conform to Editor.js format.
/// * The function encounters an unsupported block type.
///
/// # Notes
///
/// * The function assumes that the input follows the standard [Editor.js JSON format](https://editorjs.io/base-concepts).
/// * Not all Editor.js block types may be supported in the implementation.
pub fn string_to_html(str: &str) -> Result<String> {
    let document: Document = serde_json::from_str(str)
        .map_err(|e| anyhow!("Error while parsing to blocks: {}", e.to_string()))?;
    Ok(to_html(document))
}

/// Converts an Editor.js JSON value into an HTML representation.
///
/// This function takes a JSON value generated by [Editor.js](https://editorjs.io/)
/// and converts it into HTML. It is useful for rendering rich text content stored in Editor.js format
/// in web applications.
///
/// # Arguments
///
/// * `serde_json::Value` - A value containing the Editor.js JSON.
///
/// # Returns
///
/// * `Ok(String)` - The generated HTML string if the conversion is successful.
/// * `Err(anyhow::Error)` - An error if the JSON is invalid or cannot be parsed.
///
/// # Example
///
/// ```
/// let editor_json = serde_json::json!({
///     "time": 1612345678901i64,
///     "blocks": [
///         { "type": "paragraph", "data": { "text": "Hello, world!" } },
///         { "type": "header", "data": { "text": "Welcome", "level": 2 } }
///     ],
///     "version": "2.22.2"
/// });
/// let html_content = editorjs2html::value_to_html(&editor_json).unwrap();
/// assert_eq!(html_content, "<div class=\"js-para\"><p>Hello, world!</p></div><div class=\"js-head\"><h2>Welcome</h2></div>");
/// ```
///
/// # Errors
///
/// This function may return an error if:
/// * The input is not valid JSON.
/// * The JSON structure does not conform to Editor.js format.
/// * The function encounters an unsupported block type.
///
/// # Notes
///
/// * The function assumes that the input follows the standard [Editor.js JSON format](https://editorjs.io/base-concepts).
/// * Not all Editor.js block types may be supported in the implementation.
pub fn value_to_html(value: &Value) -> Result<String> {
    let document: Document = serde_json::from_value(value.clone())
        .map_err(|e| anyhow!("Error while parsing to blocks: {}", e.to_string()))?;
    Ok(to_html(document))
}

fn to_html(document: Document) -> String {
    let mut html_string = String::new();
    let mut has_toggle = false;

    let mut i = 0;
    let block_len = document.blocks.len();
    while i < block_len {
        let block = document.blocks[i].clone();
        if block.r#type == "toggle" {
            if let Some(item) = block.data.items {
                if let Some(count) = item.as_u64() {
                    has_toggle = true;
                    let label = block.data.text.unwrap_or_else(|| "Toggle".to_string());
                    let fk = block.data.fk.unwrap_or_else(|| format!("toggle-{i}"));
                    let status = block.data.status.unwrap_or_else(|| "open".into());
                    let display = if status == "closed" { "none" } else { "block" };

                    let mut nested_html = String::new();
                    for j in (i + 1)..(i + 1 + count as usize).min(block_len) {
                        let nested_block = document.blocks[j].clone();
                        nested_html.push_str(&render_block(nested_block));
                    }

                    html_string.push_str(&format!(
                    "<div class=\"js-toggle\" data-fk=\"{fk}\" data-status=\"{status}\" data-items=\"{count}\">
                        <div class=\"js-toggle-label\" onclick=\"toggleContent('{fk}')\">{label}</div>
                        <div id=\"{fk}\" class=\"js-toggle-content\" style=\"display: {display};\">
                            {nested_html}
                        </div>
                    </div>"
                ));

                    i += 1 + count as usize;
                } else {
                    i += 1;
                }
            } else {
                i += 1;
            }
        } else {
            html_string.push_str(&render_block(block));
            i += 1;
        }
    }

    if has_toggle {
        html_string.push_str(
            r#"<style>
                    .toggle-label {
                        cursor: pointer;
                        font-weight: bold;
                        padding: 0.5em;
                        background-color: #f0f0f0;
                        border: 1px solid #ccc;
                        border-radius: 5px;
                    }
                    .toggle-label:hover {
                        background-color: #e0e0e0;
                    }
                    .toggle-content {
                        padding: 0.5em 1em;
                        border-left: 2px solid #ccc;
                        margin-top: 0.5em;
                    }
                </style>
                <script>
                    function toggleContent(fk) {
                        const content = document.getElementById(fk);
                        if (!content) return;
                        const isVisible = content.style.display === 'block';
                        content.style.display = isVisible ? 'none' : 'block';
                    }
                </script>"#,
        );
    }
    html_string
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_header_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "header",
                    "data": {
                        "text": "This is a header",
                        "level": 2
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-head\"><h2>This is a header</h2></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_table_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "table",
                    "data": {
                        "withHeadings": true,
                        "content": [
                            ["Name", "Age"],
                            ["John", "30"]
                        ]
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-table\"><table><tr><th>Name</th><th>Age</th></tr><tr><td>John</td><td>30</td></tr></table></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_quote_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "quote",
                    "data": {
                        "text": "This is a quote.",
                        "caption": "Author"
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-quote\"><blockquote style=\"text-align: \">This is a quote.</blockquote> - Author</div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_checklist_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "checklist",
                    "data": {
                        "items": [
                            {"text": "Task 1", "checked": true},
                            {"text": "Task 2", "checked": false}
                        ]
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-checklist\"><div class=\"js-checkbox\"><input type=\"checkbox\" checked disabled> Task 1</div><div class=\"js-checkbox\"><input type=\"checkbox\"  disabled> Task 2</div></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_code_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "code",
                    "data": {
                        "code": "let x = 1;"
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-code\"><pre><xmp>let x = 1;</xmp></pre></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_link_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "link",
                    "data": {
                        "url": "http://example.com",
                        "text": "Example"
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-link\"><a href=\"http://example.com\" target=\"_blank\">Example</a></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_inlinetext_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "inlinetext",
                    "data": {
                        "text": "This is bold and italic",
                        "bold": true,
                        "italic": true
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-inline\"><i><b>This is bold and italic</b></i></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_warning_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "warning",
                    "data": {
                        "title": "Warning!",
                        "message": "This is a warning."
                    }
                }
            ]
        });
        let expected_html =
            "<div class=\"warning\"><strong>Warning!</strong><p>This is a warning.</p></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_image_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "image",
                    "data": {
                        "url": "http://example.com/image.jpg",
                        "caption": "An example image"
                    }
                }
            ]
        });
        let expected_html = "<div class=\"js-image\"><img src=\"http://example.com/image.jpg\">\n<div class=\"js-caption\">An example image</div></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_list_block() {
        let json_data = json!({
            "blocks": [
                {
                    "type": "list",
                    "data": {
                        "style": "ordered",
                        "items": [
                            {"content": "First item", "items": []},
                            {"content": "Second item", "items": []}
                        ]
                    }
                }
            ]
        });
        let expected_html =
            "<div class=\"js-list\"><ol><li>First item</li><li>Second item</li></ol></div>";
        assert_eq!(value_to_html(&json_data).unwrap(), expected_html);
    }

    #[test]
    fn test_paragraph_block() {
        let json_data = json!({
            "time": 1751061404527i64,
            "blocks": [
                {
                    "id": "wlMDvGrN0v",
                    "type": "paragraph",
                    "data": {
                        "text": "Text with a <a href=\"http://example.com./\">link</a>."
                    }
                }
            ],
            "version": "2.31.0-rc.7"
        });

        let expected_html = "<div class=\"js-para\"><p>Text with a <a href=\"http://example.com./\">link</a>.</p></div>";
        let html_content = value_to_html(&json_data).unwrap();
        assert_eq!(html_content, expected_html);
    }
}
